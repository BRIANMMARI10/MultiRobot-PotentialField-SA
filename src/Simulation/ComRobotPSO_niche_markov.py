from Simulation.ComRobot import ComRobot 
from Simulation.ComObject import ComObject 
from Simulation.ComRobotPSO import ComRobotPSO
from Simulation.ComRobotPSO_niche import *

from Common.utils import *
import copy
import math
isCupy = False
try:
    import cupy as np
    isCupy = True
except:
    import numpy as np
    isCupy = False
from Common import settings
from Common.DrKDtree import KDtree
import Common.settings as mySettings 
import random
from Common import utils
from Simulation.ComObjectCollection import *


special_colors = [
    "cyan",
    'royalblue',
    "lightsteelblue",
    'red',
    "purple",
    'blueviolet',
    
    "yellow",
    "lightgreen",
    "orange",
    'red',
    "white",
    # 'antiquewhite',
    # 'aqua',
    
    # 'red',
    # 'white',
    
]
# R_I = 500   # 小生境范围
# R_I = 400   # 小生境范围
# C_TH = 300  # 激活新种群的目标距离
# # NICHE_aggregation_degree_threshold = 8.0      # 子群聚集度阈值
# NICHE_aggregation_degree_threshold = 5.0      # 子群聚集度阈值
# # AGG_beta = 1.0      # 聚集度参数
# AGG_beta = 0.8      # 聚集度参数
# AGG_lambda = -0.4    # 聚集度参数 
# SIG_STEEP = 0.002
# SIG_MID = 700
# target_line_len = 300.0


step_num=10000
lr=0.01
k = 20 # 目标迭代时间
# mutate_param = 0.1 # 突变率调整参数

def getTransferMat(x):
    """Compute and return a transfer matrix based on the input values in x.

    Args:
        x (list): A list of float values to use for calculating the transfer matrix.

    Returns:
        numpy.ndarray: A square matrix of float values with dimensions n x n, 
                       where n is the length of the input list x.
    """
    n = len(x)
    mat = np.zeros((n, n), dtype=float)
    for i in range(n):
        mat[i, 0] = x[i]
    for i in range(n-1):
        mat[0, i+1] = (1-x[0])/(n-1)
        mat[i+1, i+1] = 1-x[i+1]
    return mat

def loss(x, S_0, k, S_t):
    """
    This function calculates the mean squared error between the target state S_t and 
    the predicted state S_p, where S_p is generated by running a Markov chain with 
    transition probabilities defined by a transfer matrix constructed from the input 
    parameters x.

    Args:
        x (list): A list of float values that are used to construct a transfer matrix;
                  this matrix defines the state transition probabilities.
        S_0 (numpy.ndarray): An array representing the initial state of the Markov Chain.
        k (int): The number of iterations to run the Markov Chain.
        S_t (numpy.ndarray): An array containing the target state values.

    Returns:
        float: The mean squared error between the predicted state values and the target state values.
    """
    P = getTransferMat(x)
    S_p = MarkovChain(S_0, P, k)
    return mean_squared_error(S_p, S_t)

def mean_squared_error(y, t):
    """Function to calculate the mean squared error between two arrays y and t.

    Args:
        y (numpy.ndarray): predicted array of values
        t (numpy.ndarray): target array of values

    Returns:
        float: the mean squared error between y and t
    """
    return 0.5 * np.sum((y-t)**2)# Compute the MSE using NumPy library function

def numerical_gradient(x, S_0, k, S_t):
    """Function to compute numerical gradient using finite difference method.

    Args:
        x (numpy.ndarray): state parameter used to construct probability transition matrix
        S_0 (int): initial state
        k (int): target iteration time
        S_t (int): target state

    Returns:
        numpy.ndarray: numerical gradient computed using the finite difference method
    """    
    h = 1e-4  # set a small value of h for computing finite difference
    grad = np.zeros_like(x)  # create an array of zeros with the same shape as x

    # loop over each element in x and compute numerical gradient using finite difference
    for idx in range(len(x)):
        tmp_val = x[idx]

        # compute f(x+h)
        x[idx] = tmp_val + h 
        fxh1 = loss(x, S_0, k, S_t)

        # compute f(x-h)
        x[idx] = tmp_val - h 
        fxh2 = loss(x, S_0, k, S_t)

        # compute the gradient using finite difference
        grad[idx] = (fxh1 - fxh2) / (2 * h)
        x[idx] = tmp_val  # restore the original value

    return grad

def gradient_descent(init_x, S_0, k, S_t, lr=lr, step_num=100):
    """Function to perform gradient descent optimization.

    Args:
        init_x (list): initial values of x
        S_0 (int): initial state
        k (int): target iteration time
        S_t (int): target state
        lr (float, optional): learning rate. Defaults to lr.
        step_num (int, optional): number of steps to perform. Defaults to 100.

    Returns:
        numpy.ndarray: optimized values of x
    """    
    x = np.array(init_x).astype(float)  # convert the initial values to a NumPy array of floats

    # perform gradient descent for given number of steps
    for _ in range(step_num):
        grad = numerical_gradient(list(x), S_0, k, S_t)  # compute gradient using finite difference
        grad = np.array(grad).astype(float)  # convert the gradient to a NumPy array of floats
        x -= lr * grad  # update the value of x based on the gradient and learning rate
        for i in range(x.size):
            if x[i] < 0 or x[i] >= 1:  # check if the updated value is outside the valid range
                x[i] = random.random()  # generate a random value within the valid range
    
    return x 

def MarkovChain(S_0, P, k):
    """Function to perform Markov chain simulation.

    Args:
        S_0 (list): initial state vector
        P (numpy.ndarray): transition probability matrix
        k (int): number of steps to simulate

    Returns:
        numpy.ndarray: final state vector after k steps
    """    
    S_k = copy.deepcopy(np.array(S_0).astype(float))
    for _ in range(k):
        S_k = np.matmul(S_k, P)

    return S_k

class ComRobotPSO_niche_markov(ComRobotPSO_niche):
    mutate_chance_list = {-1: 1.0}
    isSaveGroupNum = False 
    GroupNumSaveDir = ""
    isFixedMutate_chance = False
    def __init__(self, pos):
        super().__init__(pos)
        self.count = 0

    def getFoodNum(self):
        """Get the number of currently perceived targets.

        Returns:
            int: The number of currently perceived targets.
        """
        return len(ComRobotPSO_niche_markov.mutate_chance_list)-1

    def saveGroupNum(self, dir, group_num_list: list):
        """
        Save the current count and a given list of group numbers to a file.

        Args:
            dir (str): The directory and filename of the file to write to.
            group_num_list (list): A list of integers representing group numbers.

        Returns:
            None
        """
        with open(dir, 'a+') as file:
            file.write("{}".format(self.count))
            for group_num in group_num_list:
                file.write(', ')
                file.write(str(group_num))
            file.write('\n')
    
    @staticmethod
    def enableSaveGroupNum(dir):
        """
        Enable saving the current count and group numbers to a file.

        Args:
            dir (str): The directory and filename of the file to write to.

        Returns:
            None
        """
        ComRobotPSO_niche_markov.isSaveGroupNum = True
        ComRobotPSO_niche_markov.GroupNumSaveDir = dir 

    
        
    def update(self):
        """This method updates the robot. It executes multiple tasks including sensing, processing information,
        saving count and group numbers to a file if enabled, printing population counts if robot ID is 0,
        mutating robot chances based on sightings of new food sources, moving randomly or through PSO algorithm,
        and updating the counter.
        """
        self.sense()
        self.processInfo()
        # print(self.getSpecies(), self.mColor)
        if self.mId == 0:
            if ComRobotPSO_niche_markov.isSaveGroupNum:
                group_num_list = []
                for i in range(-1, 10):
                    group_num_list.append(len(ComRobotPSO_niche.PopulationGroup[i]))
                self.saveGroupNum(ComRobotPSO_niche_markov.GroupNumSaveDir, group_num_list)
            
            # print(ComRobotAF_niche_markov.mutate_chance_list)
            main_pop = len(ComRobotPSO_niche.PopulationGroup[-1])
            sub_pop0 = len(ComRobotPSO_niche.PopulationGroup[0])
            sub_pop1 = len(ComRobotPSO_niche.PopulationGroup[1])
            sub_pop2 = len(ComRobotPSO_niche.PopulationGroup[2])
            sub_pop3 = len(ComRobotPSO_niche.PopulationGroup[3])
            sub_pop4 = len(ComRobotPSO_niche.PopulationGroup[4])
            sub_pop5 = len(ComRobotPSO_niche.PopulationGroup[5])
            sub_pop6 = len(ComRobotPSO_niche.PopulationGroup[6])
            sub_pop7 = len(ComRobotPSO_niche.PopulationGroup[7])
            sub_pop8 = len(ComRobotPSO_niche.PopulationGroup[8])
            sub_pop9 = len(ComRobotPSO_niche.PopulationGroup[9])
            sub_pop10 = len(ComRobotPSO_niche.PopulationGroup[10])
            sub_pop11 = len(ComRobotPSO_niche.PopulationGroup[11])
            sub_pop12 = len(ComRobotPSO_niche.PopulationGroup[12])
            sub_pop13 = len(ComRobotPSO_niche.PopulationGroup[13])
            sub_pop14 = len(ComRobotPSO_niche.PopulationGroup[14])
            sub_pop15 = len(ComRobotPSO_niche.PopulationGroup[15])
            sub_pop16 = len(ComRobotPSO_niche.PopulationGroup[16])
            sub_pop17 = len(ComRobotPSO_niche.PopulationGroup[17])
            sub_pop18 = len(ComRobotPSO_niche.PopulationGroup[18])
            sub_pop19 = len(ComRobotPSO_niche.PopulationGroup[19])
            print("""
            main pop: {}
            sub0: {}  sub1: {}  sub2: {}  sub3: {}
            sub4: {}  sub5: {}  sub6: {}  sub7: {}
            sub8: {}  sub9: {}
            sub10: {}  sub11: {}  sub12: {}  sub13: {}
            sub14: {}  sub15: {}  sub16: {}  sub17: {}
            sub18: {}  sub19: {}
            ---------------------------------
            """.format(main_pop, 
            sub_pop0, 
            sub_pop1, 
            sub_pop2, 
            sub_pop3, 
            sub_pop4, 
            sub_pop5, 
            sub_pop6, 
            sub_pop7, 
            sub_pop8, 
            sub_pop9,
            sub_pop10, 
            sub_pop11, 
            sub_pop12, 
            sub_pop13, 
            sub_pop14, 
            sub_pop15, 
            sub_pop16, 
            sub_pop17, 
            sub_pop18, 
            sub_pop19))

        if self.getUpdateCount() > 5:
            for food in self.mFoodAll.values():
                if food.isVisible:
                    if not ComRobotPSO_niche.SpecialPool[food.mId]:
                        if self.distance(food.pos, self.pos) < C_TH:
                            print("set species {}".format(food.mId))
                            ComRobotPSO_niche.SpecialPool[food.mId] = True
                            if not ComRobotPSO_niche_markov.isFixedMutate_chance:
                                ComRobotPSO_niche_markov.mutate_chance_list[food.mId] = 0.0
                            main_population = [(agent_id, agent_pos) for agent_id, agent_pos in ComRobotPSO_niche.PopulationGroup[-1].items()]
                            for agent_id, agent_pos in main_population:
                                if self.distance(agent_pos, self.pos) < R_I:
                                    self.mPopulationAll[agent_id].setSpecies(food.mId)
                            self.updateNewMutationChance2()
                            break
        
        if self._species == -1 and self.getUpdateCount() > 5:
            for food in self.mFoodAll.values():
                if food.isVisible:
                    if ComRobotPSO_niche.SpecialPool[food.mId]:
                        # 突变为新物种的概率
                        new_species_id = self.mutateToSubspecies()
                        if new_species_id != -1:
                            self.setSpecies(new_species_id)
        elif self._species!=-1:
            
            # if len(self.mFood) > 0:
            #     print(self.distance(self.pos, self.mFood[0]))
            #     print(self.getPosFit(self.pos))
                
            if self.isReturnToMainSwarm():
                print("return main swarm: {}.{} -> main".format(self._species, self.mId))
                self.randomDistancedMove()
                # with open("/media/storage1/Code/data/AFSA/20220602003/log1.txt", 'a') as file:
                #     file.write("return main swarm: {}.{} -> main\n".format(self._species, self.mId))
                self.setSpecies(-1)

        if self._species == -1:
            self.randomMove()
        else:
            if self.getPopulationNum() < 5 and len(self.mFood)>0:
                # print(self.mFood)
                self.setTarget(self.mFood)
            else:
                self.pso()
        self.move()
        self.count += 1

    def getPopulationNum(self):
        """A function that returns the number of elements in a given population list.

        Returns:
            int: The length of the population list.
        """
        # len function is used to return the number of elements in the list mPopulation.
        return len(self.mPopulation)


    def isReturnToMainSwarm(self):
        """A function that checks whether a species mutates into the main swarm.

        Returns:
            bool: If true, indicates that the species has mutated into the main swarm.
                Otherwise, returns False.
        """
        
        if random.random() < self.getMainspeciesMutationChance(self._species):
            return True
        # aggregation_degree = self.nicheAggregationDegree()
        # if aggregation_degree > NICHE_aggregation_degree_threshold:
        #     # print(aggregation_degree)
        #     niche_size = len(self.mPopulation)
        #     current_time = self.getTime()
        #     rho_i = niche_size * AGG_lambda * (1.0/(1.0+math.e**(current_time*aggregation_degree/niche_size)) - 0.5)
            
        #     if rho_i > 1:
                
        #         dist = self.distance(self.pos, self.mFood[0])
        #         for agent_pos in self.mPopulation.values():
        #             if self.distance(self.mFood[0], agent_pos) > dist:
        #                 return False 
        #         return True 
        return False

    def mutateToSubspecies(self) -> int:
        """A function that mutates a species into its subspecies.

        Returns:
            int: The subspecies ID, if the mutation occurs. Otherwise, returns -1.
        """
            
        # Generate a random number between 0 and 1.
        rand_num = random.random()
        
        # Get the mutation chance of the current species.
        mutate_chance = self.getSubspeciesMutationChance()
        
        # Initialize the last mutation chance to 0.
        last_mutate_chance = 0
        
        # Iterate through each subspecies in the list of subspecies.
        for _key in ComRobotPSO_niche_markov.mutate_chance_list.keys():
            # If the subspecies ID is not -1 (which indicates no mutation).
            if _key != -1:
                # Check if the current random number lies within the last and current mutation chances.
                # If yes, it indicates that the mutation has occurred.
                if rand_num > last_mutate_chance and rand_num < last_mutate_chance + mutate_chance:
                    return _key
                else:
                    # Update the value of last mutation chance.
                    last_mutate_chance += mutate_chance
        
        # If none of the conditions are satisfied, return -1.
        return -1


    def getSubspeciesMutationChance(self):
        '''
        A function that calculates the probability of mutating into a subspecies.

        Returns:
            float: The probability of mutation, based on the formulae used.
        '''
        if self.getFoodNum() > 0:
            return settings.AF_MUTATE_PARAM * settings.CS_INTERVAL * (1-ComRobotPSO_niche_markov.mutate_chance_list[-1])/self.getFoodNum()
        else:
            return 0

    def getMainspeciesMutationChance(self, species_id):
        '''
        A function that calculates the probability of mutating into the main species.

        Args:
            species_id (int): The ID of the current species.

        Returns:
            float: The probability of mutation, based on the formulae used.
        '''

        # print( ComRobotAF_niche_markov.mutate_chance_list)
        return settings.AF_MUTATE_PARAM * settings.CS_INTERVAL * ComRobotPSO_niche_markov.mutate_chance_list[species_id]

    def updateNewMutationChance(self):
        """A function that updates the mutation rate.
        """        

        # Check if the mutation rate is fixed.
        if not ComRobotPSO_niche_markov.isFixedMutate_chance:
            # Get the number of food available to the species.
            food_num = self.getFoodNum()
            
            # Calculate the main and subspecies mutation rates using the sigmoid function.
            main_mu = sigmoid(-food_num, -2, 0.2)
            sub_mu = (1-main_mu)/food_num
            
            # Get the current state and set the initial state to the main mutation rate.
            S_0 = self.getState0()
            S_t  = [main_mu]
            
            # Add the subspecies mutation rates to the state list.
            for i in range(food_num):
                S_t.append(sub_mu)
                
            # Use gradient descent to get the updated mutation rates.
            x1 = np.random.random(food_num+1)
            x2 = gradient_descent(x1, S_0, k, S_t, lr=lr, step_num=step_num)
            
            # Update the mutation chance dictionary with the new values.
            for i, _key in enumerate(ComRobotPSO_niche_markov.mutate_chance_list.keys()):
                ComRobotPSO_niche_markov.mutate_chance_list[_key] = x2[i]
            
    def updateNewMutationChance2(self):
        '''
        A function that updates the mutation rate based on the average value.
        '''
        # Check if the mutation rate is fixed.
        if not ComRobotPSO_niche_markov.isFixedMutate_chance:
            # Get the current number of food available to the species.
            food_num = self.getFoodNum()
            
            # Set the main mutation rate to a fixed value and calculate the subspecies mutation rate.
            main_mu = 0.3
            sub_mu = (1-main_mu)/food_num
            
            # Get the current state and set the initial state to the main mutation rate.
            S_0 = self.getState0()
            S_t  = [main_mu]
            
            # Add the subspecies mutation rates to the state list.
            for i in range(food_num):
                S_t.append(sub_mu)
                
            # Use gradient descent to get the updated mutation rates.
            x1 = np.random.random(food_num+1)
            x2 = gradient_descent(x1, S_0, k, S_t, lr=lr, step_num=step_num)
            
            # Update the mutation chance dictionary with the new values.
            for i, _key in enumerate(ComRobotPSO_niche_markov.mutate_chance_list.keys()):
                ComRobotPSO_niche_markov.mutate_chance_list[_key] = x2[i]

    def getState0(self):
        '''
        A function that returns the current state (initial state).

        '''
        ret = []
        robots_num = self.getAllRobotsNum()

        # Calculate the proportion of robots for each species and add it to the state list.
        for species_id in ComRobotPSO_niche_markov.mutate_chance_list.keys():
            robots_num_by_species = self.getRobotsNumBySpecies(species_id)
            ret.append(robots_num_by_species / robots_num)
        return ret

    def randomDistancedMove(self):
        '''
        A function that performs a random move based on the distance from the target.

        '''
        # self.chooseRandomTarget()
        self.chooseRandomDistancedTarget()
        # self.isDistancedTravel = True